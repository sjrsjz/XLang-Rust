#import "@preview/zebraw:0.5.2": *
#show raw: it => zebraw(text(font: ("JetBrains Mono", "Microsoft YaHei UI"), it), numbering-separator:true)

#set text(font: "Microsoft YaHei UI")

= XLang-Rust 文档

#outline()

#pagebreak()

= 概述
XLang-Rust 是一个使用 Rust 语言编写的跨平台的实验性编程语言，旨在提供一种简洁而强大的编程体验。它融合了命令式和函数式编程范式的特性，致力于通过精简的语法实现复杂的功能。

= 表达式/语句
XLang-Rust 的语句结构与 Rust 类似，使用分号 `;` 作为表达式序列的分隔符。当存在多个表达式时，它们将按顺序求值，序列中最后一个表达式的求值结果将作为整个语句的值。

若表达式序列为空（例如 `( )` 或 `;` 结尾），则其求值结果为 `null`。

```xlang
print(1; 2; 3); // 输出 3，因为 3 是最后一个表达式的值
print(1;) // 输出 null，因为最后一个表达式为空
```

= 原子表达式

为了简化内部抽象语法树（AST）的构建，XLang-Rust 引入了原子表达式的概念。原子表达式是指被任何类型的括号（`()`, `[]`, `{}`) 包围的表达式，或是一个单独的词法单元（token）。
原子表达式的求值结果即为其内部表达式的求值结果。

以下均为原子表达式的示例：
```xlang
(1; 2; 3) // 被圆括号包围的表达式序列

[1, 2, 3] // 被方括号包围的列表字面量（也是原子表达式）

{1, 2, 3} // 被花括号包围的代码块（也是原子表达式）

variable // 单个标识符（变量名）

1 // 单个数字字面量

"xxx" // 单个字符串字面量

... // 其他符合定义的单个词法单元

```

= 括号/方括号/花括号

== 括号/方括号
在改变运算优先级方面，XLang-Rust 不区分圆括号 `()` 和方括号 `[]`。两者均可用于控制表达式的求值顺序。它们的区别主要体现在函数调用和索引操作上。

```xlang
(1 + 2) * 3 // 求值结果为 9
[1 + 2] * 3 // 求值结果为 9
(1 + 2) * [3] // 求值结果为 9
```

当一个非原子表达式后紧跟圆括号时，圆括号内的表达式序列将作为参数传递给前面表达式求值得到的 lambda 对象进行调用。若紧跟方括号，则方括号内的表达式序列将作为索引作用于前面表达式求值得到的元组（或其他可索引）对象。

== 花括号

花括号 `{}` 用于创建新的作用域（帧作用域）。花括号内的表达式序列将在该新作用域中执行。在此作用域内定义的变量不会影响外部作用域。花括号表达式的求值结果是其内部最后一个表达式的求值结果。
```xlang
{
    a := 1; // 在新作用域内定义 a
    b := 2; // 在新作用域内定义 b
    a + b   // 此表达式的值将作为花括号表达式的结果
} // 求值结果为 3
```

= 变量

== 变量定义/赋值
XLang-Rust 是一种动态强类型语言。变量的类型在运行时确定，但一旦确定，类型约束将被强制执行。变量可以在运行时被重新赋值为相同类型的值。

使用 `:=` 运算符在当前作用域内定义新变量并赋值。使用 `=` 运算符对已存在的变量进行赋值。

XLang-Rust 允许在同一作用域内使用 `:=` 重新定义同名变量（遮蔽）。
```xlang
a := 1; // 定义变量 a 并初始化为整数 1
```

XLang-Rust 的赋值操作是强类型的。在执行赋值（`=`）时，虚拟机会检查右侧表达式值的类型是否与变量当前持有值的类型兼容。如果不兼容，将引发 (`raise`) 一个类型错误异常。若此异常未被捕获，程序将终止并报告错误信息。

```xlang
a := 1;
a = "1"; // 引发类型错误异常，因为字符串 "1" 与整数 1 类型不兼容
a = 2;   // 合法赋值，类型匹配
a = 1.0; // 特殊情况：整数和浮点数之间存在隐式转换规则。
```

默认情况下，XLangVM 将变量名与存储在内存中的对象关联起来。变量定义实际上是在当前作用域（通常是一个哈希映射）中创建了一个指向该对象的引用。虚拟机通过变量名访问该引用。

```xlang
a := 1; // 定义变量 a，指向一个值为 1 的整数对象
b := a; // 定义变量 b，使其引用 a 所引用的同一个对象
c := a; // 定义变量 c，同样引用 a 所引用的对象
a = 2; // 对 a 进行赋值，实际上是修改了 a 所引用的那个对象的值（如果对象是可变的）或者让 a 指向一个新的值为 2 的对象（如果对象是不可变的，如基础数值类型通常处理方式）

// 假设基础类型是可变的（如下文所述），则：
assert(b == 2); // b 仍然引用同一个被修改的对象，其值已变为 2
assert(c == 2); // c 也仍然引用同一个被修改的对象，其值已变为 2
```

=== 复制

由于变量存储的是对象的引用，XLang-Rust 提供了 `copy` 和 `deepcopy` 内建函数来创建对象的副本。
`copy` 函数执行浅复制：它创建一个新对象，其内容与原对象相同。如果对象包含对其他对象的引用，则只复制引用本身，而不复制引用的目标对象。
`deepcopy` 函数执行深复制：它递归地复制对象及其包含的所有嵌套对象，确保副本与原始对象完全独立。

```xlang
a := [1, 2, 3]; // a 引用一个列表对象
b := copy a;   // b 引用 a 列表对象的浅副本

a := {
    'A' : 1,
    'B' : {
        'C' : 2,
        'D' : 3
    }
}; // a 引用一个嵌套字典对象
b := deepcopy a; // b 引用 a 字典对象的深副本
```

=== 万物皆对象

在 XLang-Rust 中，所有的数据，包括基础类型（如整数、浮点数、字符串），都被视为对象（具体实现为 `GCObject`）。因此，变量赋值传递的是对象的引用，而非值本身。这解释了以下行为：

```xlang
a := 1; // a 引用一个值为 1 的整数对象
b := a; // b 引用与 a 相同的整数对象
a = 2; // 修改 a 引用的对象的值（假设整数对象可变），或者使 a 引用一个新的值为 2 的对象

// 如果整数对象是可变的（这在某些动态语言中可能，但通常不推荐）：
assert(b == 2); // b 引用的是同一个被修改的对象

// 如果整数对象是不可变的（更常见的设计）：
// a = 2 实际上使 a 引用了一个新的值为 2 的对象。b 仍然引用值为 1 的旧对象。
// assert(b == 1); // 这种情况下 b 的值不变
```

*注：上述示例的确切行为取决于 XLang-Rust 对基础类型对象可变性的具体实现。然而，核心概念是变量持有引用。若需确保获得一个独立的值副本（即使是基础类型），应使用 `copy` 函数。*

== 变量作用域

XLang-Rust 定义了三种主要的作用域类型：函数作用域、帧作用域和边界作用域。

- *函数作用域*：在调用 lambda (函数) 时创建，用于存储函数参数和函数内部定义的局部变量。
- *帧作用域*：在执行花括号 `{}` 代码块时创建，用于隔离块内定义的变量。
- *边界作用域*：通过 `boundary` 关键字创建，功能上类似帧作用域，但具有捕获其内部 `raise` 语句的能力。

与某些语言不同，XLang-Rust 的控制流语句（如 `if`, `while`）本身不创建新的作用域。作用域的创建仅由 lambda 调用、`{}` 块和 `boundary` 块触发。这是其基于表达式的设计哲学的一部分。

`boundary` 语句创建一个边界作用域。除了提供变量隔离外，它还能捕获在其内部（包括嵌套的作用域和函数调用中）发生的 `raise` 操作。当 `raise value` 执行时，控制流将立即跳转到包含该 `raise` 的最内层 `boundary` 语句的末尾，并且整个 `boundary` 表达式的求值结果为 `value`。XLangVM 内部错误也可能自动触发 `raise`。

```xlang
A := {      // 创建帧作用域
    B := 2;
    B       // 帧作用域的最后一个表达式
};
assert(A == 2); // A 被赋值为帧作用域的结果 2

A := boundary { // 创建边界作用域
    B := 2;
    raise 1;    // 控制流跳转到 boundary 结束，值为 1
    B           // 这行代码不会执行
};

assert(A == 1); // A 被赋值为 raise 的值 1
```

*重要说明*: `boundary` 和 `raise` 并非设计为传统的异常处理机制（尽管可以模拟类似行为）。它们的主要目的是提供一种比 `return` 更强大的非局部控制转移机制，允许从深层嵌套的结构中提前返回值。

```xlang
A := boundary if true { // boundary 包裹 if 语句
    // ... 一些代码 ...
    { // 嵌套的帧作用域
        // ... 更多代码 ...
        raise 1; // 从嵌套作用域中提前返回到 boundary
        // ... 不会执行的代码 ...
    }
    // ... 不会执行的代码 ...
}
assert(A == 1); // A 的值为 1
```
这种机制同样适用于跨越函数调用的提前返回。

== 变量类型

XLang-Rust 允许显式构建如下类型：
- `var := 1;` \// 整数类型
- `var := 1.0;` \// 浮点数类型
- `var := "1";` \// 字符串类型
- `var := (1, 2, 3);`, `var := [1, 2, 3];`, `var := {1, 2, 3};` \// 元组类型
- `var := key : value;` \// 键值对类型
- `var := key => value;` \// 命名参数类型
- `var := (key : value, key2 : value2);` \// 复合键值对类型
- `var := tuple -> body;` \// lambda 函数类型
- `var := tuple -> &obj body;` \// lambda 函数类型，带捕获变量
- `var := tuple -> dyn body;` \// lambda 函数类型，动态生成指令集
- `var := tuple -> &obj dyn body;` \// lambda 函数类型，动态生成指令集，带捕获变量
- `var := int..int;` \// 区间类型，表示 [int, int)
- `var := null;` \// 空类型，表示无值
- `var := true;`, `var := false;` \// 布尔类型，表示真或假
- `var := wrap value;` \// 包装类型，表示一个值的包装对象
- `var := $"base64";` \// base64 编码的字节数组
- `var := import "path";` \// VM字节码对象，通过 import 语句导入
- `var := load_clambda("path");` \// C库对象，通过 load_clambda 语句导入
- `var := container | lambda;` \// 惰性筛选器

可以使用 `typeof value` 来获取变量的类型。
```xlang
a := 1; // 整数类型
assert(typeof a == "int"); // 类型检查
```

*注意*: 变量的类型在运行时确定，XLang-Rust 是动态类型语言。

== 变量类型转换
XLang-Rust 支持隐式和显式的类型转换。隐式转换通常在赋值或运算时自动进行，而显式转换则需要使用内建函数进行。

= 运算符

XLang-Rust 支持多种运算符，包括算术运算符、比较运算符、逻辑运算符和位运算符。具体可参考示例代码。


= 内建类型详解

XLang-Rust 提供了多种内建数据类型。所有类型都是对象，变量存储的是对象的引用。
（下述所有的 `!=` 运算均为 `==` 的反向操作因此不做介绍）

== 整数 (int)
- *描述*: 存储 64 位有符号整数 (`i64`)。
- *创建*: 通过整数常量创建，例如 `10`, `-5`, `0`。
- *操作*:
  - 算术运算: 支持 `+`, `-`, `*`, `%` (模), `**` (幂)。除法 `/` 结果总是 `float` 类型。可与 `int` 或 `float` 运算（后者结果为 `float`）。
  - 位运算: 支持 `and` (按位与), `or` (按位或), `xor` (按位异或), `not` (按位非), `<<` (左移), `>>` (右移)。
  - 比较运算: 支持 `==`, `<`, `>`。可与 `int` 或 `float` 比较。
  - 类型转换: 可转换为 `string`, `float`, `bool` (`0` 为 `false`, 其他为 `true`)。

== 浮点数 (float)
- *描述*: 存储 64 位浮点数 (`f64`)。
- *创建*: 通过浮点数常量创建，例如 `3.14`, `-0.5`（其实是用了一个neg运算）, `1e10`。
- *操作*:
  - 算术运算: 支持 `+`, `-`, `*`, `/`, `%`, `**`。可与 `int` 或 `float` 运算。
  - 比较运算: 支持 `==`, `<`, `>`。可与 `int` 或 `float` 比较。
  - 类型转换: 可转换为 `string`, `int` (截断小数部分), `bool` (`0.0` 为 `false`, 其他为 `true`)。

== 布尔 (bool)
- *描述*: 存储逻辑值 `true` 或 `false`。
- *创建*: 通过常量 `true` 和 `false` 创建。
- *操作*:
  - 逻辑运算: 支持 `and`, `or`, `xor`, `not`。
  - 比较运算: 支持 `==`。
  - 类型转换: 可转换为 `string` (`true` 或 `false`), `int` (`true` 为 `1`, `false` 为 `0`), `float` (`true` 为 `1.0`, `false` 为 `0.0`)。

== 空值 (null)
- *描述*: 表示“无值”或“未定义”的状态。
- *创建*: 通过常量 `null` 创建。空表达式序列（如 `( )` 或 `;` 结尾）的求值结果也是 `null`。
- *操作*: 仅支持 `==` 比较（`null == null` 为 `true`）。

== 键值对 (keyval)
- *描述*: 存储一个键（key）和一个值（value）的配对。通常作为元组的元素存在。
- *创建*: 使用 `key : value` 语法创建。
- *操作*:
  - 访问: 可通过 `keyof keyval_obj` 获取键，`valueof keyval_obj` 获取值。
  - 比较: `==` 比较键和值是否都相等。

== 命名参数 (named)
- *描述*: 存储一个键（通常是标识符/字符串）和一个值的配对，专门用于函数参数传递或元组内的命名项。
- *创建*: 使用 `key => value` 语法创建。语法糖 `key?` 等价于 `key => null`，`key!` 等价于 `key => key`。
- *操作*:
  - 访问: 可通过 `keyof named_obj` 获取键，`valueof named_obj` 获取值。
  - 比较: `==` 比较键和值是否都相等。

== 区间 (range)
- *描述*: 表示一个半开半闭的整数区间 `[start, end)`。
- *创建*: 使用 `start_int..end_int` 语法创建。
- *操作*:
  - 算术: `range + int`, `range - int` (移动区间两端), `range + range`, `range - range` (对应端点相加减)。
  - 包含判断: `int in range`, `sub_range in range`。
  - 长度: `len(range)` 返回 `end - start`。
  - 迭代: 可迭代区间内的所有整数（从 `start` 到 `end - 1`）。
  - 比较: `==` 比较区间的起始和结束点是否都相等。

== 字节序列 (bytes)
- *描述*: 存储一个 `u8` 字节的有序序列。
- *创建*: 使用 `$"base64_encoded_string"` 语法创建。
- *操作*:
  - 连接: `bytes1 + bytes2`。
  - 索引访问: `bytes[index]` 返回指定索引处的字节值 (作为 `int`)；`bytes[range]` 返回指定范围的子字节序列 (作为 `bytes`)。
  - 赋值修改: 支持通过索引或范围修改字节内容。
    - `bytes = index : int_0_255`：修改单个字节。
    - `bytes = index : string` 或 `bytes = index : bytes`：从指定索引开始，用字符串或字节序列的内容覆盖后续字节。
    - `bytes = range : int_0_255`：将范围内的所有字节设置为该整数值。
    - `bytes = range : string` 或 `bytes = range : bytes`：用字符串或字节序列的内容替换范围内的字节（要求长度匹配）。
  - 包含判断: `byte_int in bytes` (检查是否包含某个字节值), `sub_bytes in bytes` (检查是否包含子序列)。
  - 长度: `len(bytes)` 返回字节数。
  - 迭代: 可迭代访问序列中的每个字节 (作为 `int`)。
  - 比较: `==` 比较字节内容是否完全相同。
  - 类型转换: `string(bytes)` 尝试将字节序列按 UTF-8 解码为字符串。

== 包装器 (wrapper)
- *描述*: 包装另一个任意类型的对象。
- *创建*: 使用 `wrap value` 语法创建。
- *操作*:
  - 解包: `valueof wrapper_obj` 返回内部被包装的对象。
  - 复制/赋值: `copy`, `deepcopy`, `assign` 操作通常会委托给内部对象。

== 惰性筛选器 (set)
- *描述*: 定义一个惰性筛选操作，包含一个源容器（如元组、区间、字节序列等可迭代对象）和一个筛选 Lambda 函数。*注意：迭代此对象时，仅迭代源容器，并不会自动应用筛选 Lambda。*
- *创建*: 使用 `container | filter_lambda` 语法创建。
- *操作*:
  - 访问: `keyof set_obj` 返回源容器，`valueof set_obj` 返回筛选 Lambda。
  - 包含判断: `value in set_obj` 检查 `value` 是否在 *源容器* 中（不应用筛选）。
  - 迭代: 迭代 *源容器* 的元素（不应用筛选）。
  - 比较: `==` 比较源容器和筛选 Lambda 是否都相等。
  - 求值：`collect set_obj` 返回一个新的元组，包含源容器中所有满足筛选 Lambda 条件的元素。

== 指令集 (instructions)
- *描述*: 存储由 XLang-Rust 编译器生成的虚拟机指令包。
- *创建*: 通常由 `import "path/to/compiled.xbc"` 语句创建并赋值给变量。
- *操作*: 主要供虚拟机内部使用，作为 `lambda` 函数的执行体。用户通常不直接操作其内容。

== C Lambda 指令 (clambda)
- *描述*: 表示一个已加载的外部 C 动态链接库（DLL/SO）的接口。
- *创建*: 由 `load_clambda("path/to/library")` 语句创建并赋值给变量。
- *操作*: 主要供虚拟机内部使用，允许 `lambda` 函数调用 C 库中定义的函数。用户通常不直接操作其内容。

= 元组

XLang-Rust 的元组是一个有序的元素集合，可以包含不同类型的元素。元组是一串使用逗号 `,` 分隔的表达式。元组的长度是可变的。

尽管元组的定义不要求显式添加括号（因为括号只是用来更改运算顺序，元组构建仅依赖于逗号分隔），但为了避免歧义，建议在定义元组时使用括号。

元组和其他语言的列表类似，但是考虑到构建元组的语法，称其为元组更为合适。

== 行为
=== 元素访问
可以使用 `tuple[indx]` 来访问元组的元素。索引从 0 开始。
```xlang
tuple := (1, 2, 3); // 定义一个元组
print(tuple[0]); // 输出 1
print(tuple[1]); // 输出 2
print(tuple[2]); // 输出 3
```

可以使用 `tuple.key` 来访问元组的命名参数以及键值对。具体行为是：VM会在元组中查找键为 `key` 的命名参数或者键值对，如果找到，则返回对应的 `value`。如果没有找到，则 `raise` 一个异常。

默认情况下，AST 会视 `tuple.key` 中的 `key` 为一个字符串字面量（`"key"`），但如果 `key` 是一个变量，如果要显式动态生成键，可以使用帧作用域包裹表达式来避免 AST 的错误解析。

```xlang
tuple := {
    'A0' => 1,
    'B0' : 2,
    'C0' : 3
};
assert (tuple.A0 == 1); // 访问命名参数 A0
assert (tuple.(A0) == 1); // 访问命名参数 A0，括号仅仅是为了改变运算顺序
assert (tuple.{'B' + '0'} == 2); // 访问键值对 B0
```

可以使用内建的 `len(tuple)` 函数来获取元组的长度。

=== Lambda参数赋值
当调用一个 Lambda 函数时，传递给它的参数（构成一个调用参数元组）会按照特定规则赋值给 Lambda 定义时声明的参数（构成 Lambda 的参数元组）。赋值过程如下：

+  *参数分类*：首先，将调用时提供的参数分为两类：
    +   *命名参数*：形如 `key => value`
    +   *位置参数*：其他没有显式指定键的参数值。

+  *处理命名参数*：
    +   系统会遍历调用时提供的所有*命名参数*。
    +   对于每一个命名参数，会在 Lambda 定义的参数元组中查找具有*相同键*的参数。
    +   如果找到了匹配的键，则将调用时命名参数的*值*赋给 Lambda 定义中对应键的参数。
    +   如果在 Lambda 定义的参数元组中*没有*找到匹配的键，则这个来自调用的命名参数（键和值）会被*添加*到当前 Lambda 调用的参数元组中。

+  *处理位置参数*：
    +   在处理完所有命名参数后，系统会按顺序处理调用时提供的 *位置参数*。
    +   对于每一个位置参数，系统会在 Lambda 定义的参数元组中查找下一个 *尚未被赋值* 的参数槽位。
    +   如果找到了这样的槽位，则将该位置参数的值赋给这个槽位。
    +   如果 Lambda 定义的参数元组中所有槽位都已被赋值（无论是通过匹配命名参数还是先前的位置参数），那么多余的位置参数会被 *追加* 到当前 Lambda 调用的参数元组末尾。

这个赋值过程允许灵活地混合使用命名参数和位置参数，优先通过键匹配，然后按顺序填充剩余的位置，并能动态扩展参数列表以容纳额外的参数。


= Lambda 函数
XLang-Rust 的设计思想是完全抛弃传统的固定分配函数名称的方式，转而完全使用 lambda 函数（匿名函数）来实现函数的定义和调用。这意味着函数的定义和调用都是动态的。

== 定义
XLang-Rust 的函数定义使用 `->` 符号。函数可以接受参数，并返回一个值。函数体可以是一个表达式。

具体来说，XLang-Rust 的函数定义语法如下：

```
atomic_expression -> <&atomic_expression> <dyn> expression
```
#text(red)[其中 `atomic_expression` 是一个原子表达式，表示函数的参数列表；`<&atomic_expression>` 表示函数体中可以捕获的变量；`<dyn>` 表示动态生成指令集的标志；`expression` 是函数体的表达式。尖括号内的内容是可选的。]

XLang-Rust 要求静态定义的函数的所有参数都必须是命名参数（即 `key => value` 形式）。

为了使得代码更加简洁，XLang-Rust 提供了两个语法糖 `x?` 和 `x!`，分别等价于 `x => null` 和 `x => x`。

```xlang
// 定义一个简单的函数，接受一个参数并返回其平方
square := (x => 0) -> x * x; // 定义一个函数 square，接受一个参数 x，返回 x 的平方

// 然后调用这个函数
result := square(5); // 调用 square 函数，传入参数 5，结果为 25
```

XLang-Rust 的Lambda函数有以下特性：
- Lambda的参数绝对是一个元组（tuple）。可以使用 `keyof lambda` 来获取参数元组（一般是完全由命名参数组成）。
- 在静态分析模式下，Lambda的参数必须是命名参数（即 `key => value` 形式）。除非在定义时使用 `@dynamic` 注解绕过静态分析。
- 除非Lambda被GC回收，否则其参数和返回值会持续存在于内存中，不随着函数调用的结束而消失。
- Lambda的参数和返回值可以是任意类型，这保证了函数的灵活性和可扩展性。

也就是说下面的代码是合法的：
```xlang
// 定义一个函数，接受一个参数并返回其平方
square := (x => 0) -> x * x; // 定义一个函数 square，接受一个参数 x，返回 x 的平方
square(5);

print(valueof square); // 打印函数 square 缓存的值，输出 `5`
```

这也意味着 XLang-Rust 其实将Lambda视为一种可以动态计算的键值对，其值只在被调用时才会被计算并在此之后长期缓存。

== Lambda 函数的调用

XLang-Rust 的函数调用使用 `()` 符号。函数调用的参数可以是任意类型的表达式，包括其他函数的返回值。

一般情况下，AST会将调用里的非元组表达式转换为元组表达式以适配单参数函数调用。但是这种情况导致了一个问题：
如果函数的参数是单个的元组，那么AST会认为这个元组是实际上的传参，而不是函数的参数。如下代码所示：
```xlang
lambda((1, 2, 3));// 它实际上是传递了三个参数，而不是一个元组参数！

// 如果想要传递一个元组参数，可以使用以下方式：
lambda((1, 2, 3),); // 传递一个元组参数（使用逗号告诉AST这是一个单参数的调用）
```

如果想要将一个元组变量的值当作参数传递给函数，可以使用 `...` 符号来解包元组（仅限单参数）

```xlang
lambda(...(1, 2, 3)); // 将元组 (1, 2, 3) 解包为三个参数传递给函数
```

同理 `...` 也可以用在Lambda的定义上，表示这个Lambda的参数定义是由一个元组的值提供的

一旦Lambda被调用，VM先会创建一个函数作用域，然后尝试解包参数并尝试将所有的命名参数挂载到当前的作用域上（成功与否在于键是否是一个字符串），之后开始执行函数体。

== 协程

=== 协程的定义
XLangVM是基于更为抽象和通用的协程设计的，因此任何使用VM指令集的函数都可以被视为一个协程直接启动

协程一旦运行就不会停止，直到它完成，这和其他语言的协程设计是不同的。其更像是一个线程的设计。

=== 协程的调用
使用 `async lambda()` 来以异步方式调用一个函数。
```xlang
my_async_function := () -> {
    // 这里是异步函数的代码
    return 42; // 返回一个值
};

async my_async_function(); // 调用异步函数
```

协程的返回值会被缓存到Lambda对象中，直到被GC回收。

XLangVM下所有协程都是同级别的，只有协程池被完全清空后，VM才会停止运行。

=== yield语句
使用 `yield expr` 语句可以将当前协程的返回值设置成为 `expr` 计算的值，但是不会停止协程的运行。

```xlang
my_coroutine := () -> {
    yield 42; // 将当前协程的返回值设置为 42
    // 这里是协程的其他代码
};
```

其他协程可以随时使用 `valueof` 来获取当前协程的返回值。

=== await语句
使用 `await lambda` 语句可以阻塞当前协程，直到 `lambda` 协程完成并返回值。

=== 行为
一旦一个协程被创建，它就会立即开始执行。启动的协程不会继承调用者的作用域。只有内建函数和参数会被附加到该协程的作用域上。

这使得XLang-Rust的协程更趋向于纯的以减少副作用。

== 赋值
对Lambda的赋值仅仅只会将键（参数），值（返回值）和上下文（捕获的变量）赋值到指定的对象上。

== 对象绑定
XLang-Rust 提供关键字 `bind obj` 来将一个元组里的所有Lambda以及所有命名参数的值（如果是Lambda）的 `self` 引用绑定为该元组自身。因此可以使用 `bind` 关键字来模拟类的行为。

```xlang
obj := bind {
    'v' : 'Hello World',
    say => () -> {
        print(self.v); // 访问绑定的对象的属性
    }
};
obj.say(); // 调用绑定的对象的"方法"
```

== self变量
`self` 变量是一个特殊的变量，用于指代当前Lambda所绑定的对象。它可以在Lambda内部被访问和使用。
`self` 变量的值是由 `bind` 关键字绑定的对象。

== this变量
`this` 变量是一个特殊的变量，用于指代当前Lambda自身。它可以在Lambda内部被访问和使用。

```xlang
fib := (n => 0) -> {
    if n < 2 {
        return n; // 返回 n
    } else {
        return this(n - 1) + this(n - 2); // 递归调用自身
    }
};
print(fib(10)); // 输出斐波那契数列的第 10 项
```

== return语句
`return` 语句用于从当前函数或协程中返回一个值。它会立即终止函数的执行，并将指定的值作为结果缓存到函数对象中然后返回。
`return` 语句可以在函数的任何位置使用。

== dyn标记
使用 `dyn` 标记可以将一个函数标记为动态生成的函数。动态生成的函数会在运行时根据传入的指令集进行Lambda的构建。

== 模块
每一个XLang-Rust的源文件都是一个“模块”，其被编译成VM字节码文件。当VM加载一个模块时，它会执行如下操作：
+ 载入模块的字节码文件，并将其装载进VM
+ 隐式构建一个Lambda对象，指令集为该模块的字节码
+ 执行这个隐式构建的Lambda对象

上述过程等价于下面的代码：
```xlang
__new_module := import "path/to/module.xbc"; // 载入模块的字节码文件
__entry := () -> dyn __new_module; // 隐式构建一个Lambda对象，指令集为该模块的字节码
__entry(); // 执行这个隐式构建的Lambda对象
```

同时上述代码也是 XLang-Rust 实现模块化的基础。

== 变量捕获

XLang-Rust 支持在 Lambda 函数中捕获外部变量。使用 `&` 符号来捕获一个原子表达式求值的结果。

可以使用 `captureof lambda` 或者 `$lambda` 来获取 Lambda 函数捕获的变量。

```xlang
a := 1; // 定义一个变量 a
foo := () -> &a {
    print($this.a); // 打印本函数捕获的变量 a 的值
};
foo(); // 调用函数 foo，输出 1
print(captureof foo); // 打印捕获的变量 a 的值，输出 1。也可以写为 `print($foo)`。
```

当然，我们也可以暴力使用参数来捕获变量：
```xlang
a := 1; // 定义一个变量 a
foo := (a!) -> {
    print(a); // 打印参数 a 的值
};
foo(); // 调用函数 foo，输出 1
```

区别在于：
- 使用 `&` 捕获的变量是一个纯引用，一旦构建不可能对其类型进行修改。
- 使用参数捕获的变量和一般的变量一样，可以使用 `:=` 来遮蔽掉原有的变量。